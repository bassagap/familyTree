<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  text-align: center;
}

svg {
  margin-top: 32px;
  border: 1px solid #aaa;
}

.male {
  fill: #663300;

}
.female {
  fill: #000;

}

.person {
  font: 14px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}
.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}

</style>
<body>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
<script>

var boxWidth = 40,
    boxHeight = 40;

// Define the div for the tooltip
var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    return "<strong>Name:</strong> <span style='color:red'>" + d.name + "</span>";
  })

// Setup zoom and pan
var zoom = d3.behavior.zoom()
  .scaleExtent([.1,1])
  .on('zoom', function(){
    svg.attr("transform", "translate(" + d3.event.translate + ") scale(" + d3.event.scale + ")");
  })
  // Offset so that first pan and zoom does not jump back to the origin
  .translate([150, 200]);

var svg = d3.select("body").append("svg")
  .attr('width', 1000)
  .attr('height', 500)
  .call(zoom)
  .append('g')
  // Left padding of tree so that the whole root node is on the screen.
  // TODO: find a better way
  .attr("transform", "translate(150,200)");
svg.call(tip);
var tree = d3.layout.tree()
  // Using nodeSize we are able to control
  // the separation between nodes. If we used
  // the size parameter instead then d3 would
  // calculate the separation dynamically to fill
  // the available space.
  .nodeSize([100, 200])
  // By default, cousins are drawn further apart than siblings.
  // By returning the same value in all cases, we draw cousins
  // the same distance apart as siblings.
  .separation(function(){
    return .5;
  })
  // Tell d3 what the child nodes are. Remember, we're drawing
  // a tree so the ancestors are child nodes.
  .children(function(person){
    return person._parents;
  });

d3.json('data/4gens.json', function(error, json){
  
  if(error) {
    return console.error(error);
  }
  
  var nodes = tree.nodes(json),
      links = tree.links(nodes);
  // Style links (edges)
  svg.selectAll("path.link")
      .data(links)
    .enter().append("path")
      .attr("class", "link")
      .attr("d", elbow);

  // Style nodes    
  var node = svg.selectAll("g.person")
      .data(nodes)
    .enter().append("g")
 		.attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });


  // Draw the rectangle person boxes
  node.append("rect").filter(function(d) {return d.gender == "male";})
      .attr({
        x: -(boxWidth/2),
        y: -(boxHeight/2),
        width: boxWidth,
        height: boxHeight
      })
      .attr("class", function(d) {return d.gender;})   
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide);   
 node.append("circle").filter(function(d) {return d.gender == "female";})
      .attr({
        cx: -(boxWidth/12),
        cy: -(boxWidth/8),
        r: boxWidth/2,
      })
      .attr("class", function(d) {return d.gender;})   
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide);   

});

    
/**
 * Custom path function that creates straight connecting lines.
 */
function elbow(d) {
  return "M" + d.source.y + "," + d.source.x
    + "H" + (d.source.y + (d.target.y-d.source.y)/2)
    + "V" + d.target.x 
    + "H" + d.target.y;
}

</script>